{"ast":null,"code":"import { createVNode as _createVNode, createElementVNode as _createElementVNode, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(_Fragment, null, [_cache[0] || (_cache[0] = _createElementVNode(\"svg\", {\n    id: \"stage\",\n    class: \"_fullscreen\"\n  }, null, -1 /* HOISTED */)), _createVNode($setup[\"Resettip\"], {\n    ref: \"resettip\"\n  }, null, 512 /* NEED_PATCH */), _createVNode($setup[\"Readytips\"], {\n    ref: \"readytips\"\n  }, null, 512 /* NEED_PATCH */), _createVNode($setup[\"Summary\"], {\n    ref: \"summary\"\n  }, null, 512 /* NEED_PATCH */), _createVNode($setup[\"Databox\"])], 64 /* STABLE_FRAGMENT */);\n}","map":{"version":3,"names":["_createElementBlock","_Fragment","_createElementVNode","id","class","_createVNode","$setup","ref"],"sources":["E:\\SnakeBall\\src\\components\\game\\stage.vue"],"sourcesContent":["<template>\r\n    <svg id=\"stage\" class=\"_fullscreen\" />\r\n    <Resettip ref=\"resettip\" />\r\n    <Readytips ref=\"readytips\" />\r\n    <Summary ref=\"summary\" />\r\n    <Databox />\r\n</template>\r\n\r\n<script setup>\r\nimport { global } from \"@/stores/global\";\r\nimport Resettip from \"@/components/game/resettip.vue\";\r\nimport Readytips from \"@/components/game/readytips.vue\";\r\nimport Summary from \"@/components/game/summary.vue\";\r\nimport Databox from \"@/components/game/databox.vue\";\r\nimport { onMounted, ref } from \"vue\";\r\nimport gsap from \"gsap\";\r\nimport forge from \"node-forge\";\r\nconst store = global();\r\nconst player = store.player;\r\nconst audio_controller = store.audio_controller;\r\n// 组件\r\nconst readytips = ref(null);\r\nconst summary = ref(null);\r\nconst resettip = ref(null);\r\n//游戏舞台SVG\r\nlet stage;\r\nlet scale_stander; //缩放标准系数：用于让舞台在不同尺寸的屏幕上保持一致的大小\r\nfunction resize() {\r\n    // 缩放系数以最短边来计算\r\n    scale_stander = innerWidth <= innerHeight ? innerWidth / 1000 : innerHeight / 1000;\r\n    stage.setAttribute(\"viewBox\", `0 0 ${innerWidth} ${innerHeight}`);\r\n    snakeball.resize();\r\n}\r\n// 闪烁：目标元素改变颜色，短时间后回复\r\nfunction flicker(ball, color) {\r\n    gsap.timeline()\r\n        .set(ball, {\r\n            fill: color,\r\n        })\r\n        .set(\r\n            ball,\r\n            {\r\n                fill: \"\",\r\n            },\r\n            \"<0.5\"\r\n        );\r\n}\r\n// snakeball控制对象\r\nconst snakeball = {\r\n    balls: [], //所有的头部/身体svg元素\r\n    // 头部的参考半径/实际半径：用参考半径是为了让snakeball适应不同的屏幕尺寸\r\n    head_radius: {\r\n        ref: 12,\r\n        act: 0,\r\n    },\r\n    // 身体部分的参考半径/实际半径\r\n    body_radius: {\r\n        ref: 6,\r\n        act: 0,\r\n    },\r\n    // 起始xy位置:设置为屏幕左上方外部\r\n    start_x: -20,\r\n    start_y: -20,\r\n    // 水平方向移动距离：用于控制snakeball在水平方向的身体朝向\r\n    distance_x: 0,\r\n    // 移动时间\r\n    duration: {\r\n        smooth: [0, 0.3], //顺滑的移动值区间\r\n        unsmooth: [0.7, 1], //不顺滑的移动值区间\r\n        default: 0.1, //默认值\r\n        act: 0, //实际值\r\n    },\r\n    // 身体的延迟移动间隔时间\r\n    delay: {\r\n        smooth: [0.05, 0.25],\r\n        // delay的不顺滑值有两段，过快或者过慢都会影响玩家的操纵\r\n        unsmooth: [\r\n            [0, 0.01],\r\n            [0.3, 0.5],\r\n        ],\r\n        default: 0.05,\r\n        act: 0,\r\n    },\r\n    // 每一次reset能够顺滑操控snakeball的概率值：获得顺滑duration和delay的概率\r\n    smooth_prob: 0.85,\r\n    // 重置器\r\n    reseter: {\r\n        timer: null, //定时器\r\n        max: 7000, //最长重置间隔时间\r\n        min: 3000, //最短重置间隔时间\r\n        // 启动重置器\r\n        run() {\r\n            this.stop();\r\n            // 设置随机时间触发reset\r\n            this.timer = setTimeout(\r\n                snakeball.reset.bind(snakeball),\r\n                Math.random() * (this.max - this.min) + this.min\r\n            );\r\n        },\r\n        // 停止重置器\r\n        stop() {\r\n            clearTimeout(this.timer);\r\n        },\r\n    },\r\n    resize() {\r\n        // 重新计算头部和身体的实际半径\r\n        this.head_radius.act = this.head_radius.ref * scale_stander;\r\n        this.body_radius.act = this.body_radius.ref * scale_stander;\r\n        // 如果snakeball已经创建，则更改全部半径\r\n        if (!this.balls.length) return;\r\n        this.balls.forEach((ball, index) => {\r\n            if (index === 0) ball.setAttribute(\"r\", this.head_radius.act);\r\n            else ball.setAttribute(\"r\", this.body_radius.act);\r\n        });\r\n    },\r\n    // 创建snakeball\r\n    create(lives) {\r\n        this.balls = []; //清空所有ball\r\n        // 根据当前生命值创建snakeball\r\n        for (let i = 0; i < lives + 1; i++) {\r\n            this.create_ball(i === 0 ? \"head\" : \"body\");\r\n        }\r\n        // 设置默认duration和delay\r\n        this.duration.act = this.duration.default;\r\n        this.delay.act = this.delay.default;\r\n        this.bind_events(); // 绑定事件\r\n        // 将snakeball移动到屏幕中间，即使玩家未移动鼠标\r\n        this.move(innerWidth / 2, innerHeight / 2);\r\n    },\r\n    // 绑定事件:鼠标/手指移动、可以操控snakeball移动\r\n    bind_events() {\r\n        stage.onmousemove = (e) => {\r\n            this.move(e.x, e.y);\r\n        };\r\n        stage.ontouchmove = (e) => {\r\n            this.move(e.touches[0].clientX, e.touches[0].clientY);\r\n        };\r\n    },\r\n    // 创建小球元素：snakeball的头/身体部分\r\n    create_ball(type) {\r\n        let ball = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\r\n        // 计算xy坐标：用pos_x，pos_y储存位置信息，方便后续不使用DOM方式查找\r\n        ball.pos_x = this.start_x + this.balls.length * this.body_radius.act;\r\n        ball.pos_y = this.start_y;\r\n        // 设置对应DOM属性\r\n        ball.setAttribute(\"fill\", \"var(--color_front)\");\r\n        ball.setAttribute(\"cx\", ball.pos_x);\r\n        ball.setAttribute(\"cy\", ball.pos_y);\r\n        ball.setAttribute(\"r\", type === \"head\" ? this.head_radius.act : this.body_radius.act);\r\n        // 将ball添加到stage和balls数组\r\n        stage.appendChild(ball);\r\n        this.balls.push(ball);\r\n        return ball;\r\n    },\r\n    // 移动snakeball\r\n    move(x, y) {\r\n        let direction_x = x - this.start_x - this.distance_x; //snakeball的水平x轴移动方向\r\n        this.distance_x = x - this.start_x; //更新distance_x\r\n        this.balls.forEach((ball, index) => {\r\n            //计算snakeball的x方向移动距离\r\n            x = this.start_x + index * this.body_radius.act + this.distance_x;\r\n            // 根据移动方向调整身体位置：无论蛇头朝向哪个水平方向，身体总是在蛇头的后面\r\n            if (direction_x > 0 && index !== 0) x -= 2 * index * this.body_radius.act;\r\n            // 移动\r\n            this.set_location(ball, x, y, index);\r\n        });\r\n    },\r\n    // 设置ball的xy坐标位置\r\n    set_location(ball, x, y, index) {\r\n        gsap.to(ball, {\r\n            pos_x: x,\r\n            pos_y: y,\r\n            cx: x,\r\n            cy: y,\r\n            duration: this.duration.act,\r\n            ease: \"linear\",\r\n            delay: index * this.delay.act,\r\n        });\r\n    },\r\n    // 重置snakeball的移动速度、身体延迟移动间隔、以及重置周期\r\n    reset() {\r\n        //播放reset动画和声音\r\n        resettip.value.reset();\r\n        audio_controller.reset.play();\r\n        // 重置duration\r\n        let if_duration_smooth = Math.random() < this.smooth_prob ? \"smooth\" : \"unsmooth\";\r\n        this.duration.act =\r\n            Math.random() *\r\n                (this.duration[if_duration_smooth][1] - this.duration[if_duration_smooth][0]) +\r\n            this.duration[if_duration_smooth][0];\r\n        // 重置delay\r\n        if (Math.random() < this.smooth_prob) {\r\n            // 设置delay为顺滑\r\n            this.delay.act =\r\n                Math.random() * (this.delay.smooth[1] - this.delay.smooth[0]) +\r\n                this.delay.smooth[0];\r\n        } else {\r\n            // 设置delay为不顺滑\r\n            let index = Math.random() >= 0.5 ? 0 : 1; //随机取过快或过慢区间\r\n            this.delay.act =\r\n                Math.random() * (this.delay.unsmooth[index][1] - this.delay.unsmooth[index][0]) +\r\n                this.delay.unsmooth[index][0];\r\n        }\r\n        // 重置reseter\r\n        this.reseter.run();\r\n    },\r\n    // 获得生命值\r\n    get_lives() {\r\n        flicker(this.balls, \"#0ee515\"); // 闪烁颜色\r\n        this.create_ball(\"body\"); // 添加新的身体元素\r\n        player.lives++; //生命值增加\r\n    },\r\n    // 失去生命值\r\n    lost_lives() {\r\n        flicker(this.balls, \"#e3d80f\"); // 闪烁颜色\r\n        // 移除stage以及数组中的ball元素\r\n        stage.removeChild(this.balls[this.balls.length - 1]);\r\n        this.balls.pop();\r\n        player.lives--; //生命值减少\r\n        // 如果生命值小于等于0，则触发游戏失败事件\r\n        if (player.lives <= 0) game_controler.over(false);\r\n    },\r\n    // 摧毁，清除snakeball\r\n    remove() {\r\n        // 移除鼠标事件\r\n        stage.onmousemove = stage.ontouchmove = null;\r\n        // 播放snakeball爆炸动画：这里不清除是因为再开始游戏的时候、会直接清空stage\r\n        gsap.to(this.balls, {\r\n            fill: \"#e3d80f\",\r\n            stroke: \"#dc1130\",\r\n            strokeWidth: this.body_radius.act / 5, //这里用半径计算线条宽度、是为了不让其受屏幕尺寸影响\r\n            r: 2 * this.body_radius.act,\r\n            opacity: 0,\r\n            duration: 0.6,\r\n            ease: \"power3.out\",\r\n            stagger: 0.01,\r\n        });\r\n    },\r\n    // 改变snakeball的颜色，恢复颜色后、执行后续功能\r\n    change_color(color, duration, next) {\r\n        gsap.timeline()\r\n            .set(this.balls, {\r\n                fill: color,\r\n            })\r\n            .set(\r\n                this.balls,\r\n                {\r\n                    fill: \"\",\r\n                    onComplete: () => {\r\n                        if (next) next(); //存在后续功能，则执行\r\n                    },\r\n                },\r\n                `<${duration}` //duration时间后、恢复颜色\r\n            );\r\n    },\r\n};\r\n// 子弹球\r\nclass bulletball {\r\n    constructor(r, pos_x, pos_y, speed_x, speed_y, type, color) {\r\n        this.r = r; //子弹球半径\r\n        this.pos_x = pos_x; // x位置\r\n        this.pos_y = pos_y; // y位置\r\n        this.speed_x = speed_x; //x方向移动速度\r\n        this.speed_y = speed_y; //y方向移动速度\r\n        this.type = type; //子弹球类型\r\n        this.color = color; //子弹球颜色\r\n        this.move_timer = null; //移动定时器\r\n        this.ball = null; ///DOM元素、SVG\r\n        this.if_removed = false; //是否被移除：用于防止子弹球被多次移除导致BUG\r\n    }\r\n    // 创建子弹球\r\n    create() {\r\n        this.ball = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\r\n        // 设置对应DOM属性\r\n        this.ball.setAttribute(\"cx\", this.pos_x);\r\n        this.ball.setAttribute(\"cy\", this.pos_y);\r\n        this.ball.setAttribute(\"r\", this.r);\r\n        this.ball.setAttribute(\"fill\", this.color);\r\n        // 添加到stage\r\n        stage.appendChild(this.ball);\r\n        // 启动移动定时器：移动子弹球\r\n        this.move_timer = setInterval(this.move.bind(this), 30);\r\n    }\r\n    // 移动子弹球\r\n    move() {\r\n        // 更新xy位置\r\n        this.pos_x += this.speed_x;\r\n        this.pos_y += this.speed_y;\r\n        // 移动子弹球\r\n        gsap.set(this.ball, {\r\n            cx: this.pos_x,\r\n            cy: this.pos_y,\r\n        });\r\n        // 每次移动后，检测是否发生撞击\r\n        this.check_crash();\r\n    }\r\n    // 检测是否与snakeball发生了撞击\r\n    check_crash() {\r\n        for (let i = 0; i < snakeball.balls.length; i++) {\r\n            // 计算到snakeball的头/身体的xy距离\r\n            let distance_x = this.pos_x - snakeball.balls[i].pos_x;\r\n            let distance_y = this.pos_y - snakeball.balls[i].pos_y;\r\n            // 如果撞到了头部:\r\n            if (\r\n                i === 0 &&\r\n                Math.abs(distance_x) <= snakeball.head_radius.act + this.r &&\r\n                Math.abs(distance_y) <= snakeball.head_radius.act + this.r\r\n            )\r\n                // 触发撞击头的事件函数\r\n                return this.crash_head(this);\r\n            // 如果撞到了身体部分:\r\n            else if (\r\n                i !== 0 &&\r\n                Math.abs(distance_x) <= snakeball.body_radius.act + this.r &&\r\n                Math.abs(distance_y) <= snakeball.body_radius.act + this.r\r\n            )\r\n                // 触发撞击身体部分的事件函数;\r\n                return this.crash_body(this);\r\n        }\r\n        // 如果子弹球移出界面范围，则直接被移除\r\n        if (\r\n            this.pos_x > innerWidth + this.r ||\r\n            this.pos_x < -this.r ||\r\n            this.pos_y > innerHeight + this.r ||\r\n            this.pos_y < -this.r\r\n        )\r\n            return this.remove();\r\n    }\r\n    // 碰撞到snakeball头部\r\n    crash_head(ball) {\r\n        player.score += launcher.types[this.type].score; //获得对应的分数\r\n        this.remove(); // 子弹球直接被移除\r\n        let trigger_head = launcher.types[this.type].trigger_head.bind(this); //触发撞击头部的事件函数\r\n        return trigger_head();\r\n    }\r\n    // 碰撞到snakeball身体部分\r\n    crash_body(ball) {\r\n        player.score += launcher.types[this.type].score; //获得对应的分数\r\n        this.destroy(); // 子弹球爆炸摧毁并被移除\r\n        let trigger_body = launcher.types[this.type].trigger_body.bind(this); //触发撞击身体的事件功能\r\n        return trigger_body();\r\n    }\r\n    // 摧毁子弹球\r\n    destroy() {\r\n        this.if_removed = true; //标记被移除\r\n        clearInterval(this.move_timer); //清除移动定时器\r\n        // 随机播放爆炸音效\r\n        audio_controller.blasts[parseInt(Math.random() * audio_controller.blasts.length)].play();\r\n        // 播放爆炸动画\r\n        gsap.to(this.ball, {\r\n            fill: \"#e3d80f\",\r\n            stroke: \"#dc1130\",\r\n            strokeWidth: this.r / 5,\r\n            r: 2 * this.r,\r\n            opacity: 1, //恢复透明度：小球爆炸时可能在隐身状态，但是需要其爆炸可以被看到\r\n            duration: 0.3,\r\n            ease: \"power3.out\",\r\n            onComplete: () => {\r\n                this.remove(); // 动画完成之后,再移除子弹球\r\n            },\r\n        });\r\n    }\r\n    // 移除子弹球\r\n    remove() {\r\n        this.if_removed = true; //标记被移除\r\n        clearInterval(this.move_timer); //清除移动定时器\r\n        // 从stage和launcher中移除子弹球\r\n        stage.removeChild(this.ball);\r\n        delete launcher.balls[this.index];\r\n    }\r\n}\r\n// 炮台：子弹球发射器\r\nconst launcher = {\r\n    // 所有种类的子弹球\r\n    types: {\r\n        // 火球：碰撞到头部失去一条生命值\r\n        fireball: {\r\n            type: \"fireball\",\r\n            r: 6, //参考半径\r\n            color: \" #dc1130\", //颜色\r\n            score: 1, //碰撞所获得的得分\r\n            prob: 0, //发射该子弹球的概率\r\n            // 碰到头部触发的事件\r\n            trigger_head() {\r\n                audio_controller.warn.play(); //播放警示音效\r\n                snakeball.lost_lives(); //snakeball失去一条生命\r\n            },\r\n            // 碰到身体部分触发的事件\r\n            trigger_body() {},\r\n        },\r\n        // 医药球：碰撞到头部增加一条生命值\r\n        medicineball: {\r\n            type: \"medicineball\",\r\n            r: 12,\r\n            color: \" #0ee515\",\r\n            score: 3,\r\n            prob: 0.85,\r\n            trigger_head() {\r\n                audio_controller.buff.play(); //播放增益效果音效\r\n                snakeball.get_lives(); //snakeball获得一条生命\r\n            },\r\n            trigger_body() {},\r\n        },\r\n        // 冷冻球\r\n        frozenball: {\r\n            type: \"frozenball\",\r\n            r: 10,\r\n            color: \" #16b7df\",\r\n            score: 5,\r\n            prob: 0.95,\r\n            // 短时间内，减速屏幕内所有子弹球\r\n            trigger_head() {\r\n                audio_controller.buff.play(); //播放增益效果音效\r\n                Object.values(launcher.balls).forEach((ball) => {\r\n                    flicker(ball.ball, \"#16b7df\"); // 闪烁子弹球颜色\r\n                    // 减慢子弹球速度\r\n                    ball.speed_x /= 20;\r\n                    ball.speed_y /= 20;\r\n                    // 一段时间后减速失效\r\n                    setTimeout(() => {\r\n                        ball.speed_x *= 20;\r\n                        ball.speed_y *= 20;\r\n                    }, 1000);\r\n                });\r\n            },\r\n            // 冰冻减速snakeball\r\n            trigger_body() {\r\n                // 判断是否在冰冻生效时间中：临时储存snakeball的duration和delay\r\n                if (!launcher.types[\"frozenball\"].if_effected) {\r\n                    launcher.types[\"frozenball\"].if_effected = true;\r\n                    launcher.types[\"frozenball\"].tem_duration = snakeball.duration.act;\r\n                    launcher.types[\"frozenball\"].tem_delay = snakeball.delay.act;\r\n                } else {\r\n                    // 储存并清除定时器：防止多次触发、定时器堆叠导致效果时长不够\r\n                    if (launcher.types[\"frozenball\"].timer)\r\n                        clearTimeout(launcher.types[\"frozenball\"].timer);\r\n                }\r\n                // 设置最大延迟的duration和delay: 使snakeball移动变慢;\r\n                snakeball.duration.act = snakeball.duration.unsmooth[1];\r\n                snakeball.delay.act = snakeball.delay.unsmooth[1][1];\r\n                // 标识颜色\r\n                gsap.set(snakeball.balls, {\r\n                    fill: \"#16b7df\",\r\n                });\r\n                // 短时间后，恢复原始发射频率\r\n                launcher.types[\"frozenball\"].timer = setTimeout(() => {\r\n                    launcher.types[\"frozenball\"].if_effected = false;\r\n                    // 恢复duration和delay\r\n                    snakeball.duration.act = launcher.types[\"frozenball\"].tem_duration;\r\n                    snakeball.delay.act = launcher.types[\"frozenball\"].tem_delay;\r\n                    // 恢复颜色\r\n                    gsap.set(snakeball.balls, {\r\n                        fill: \"\",\r\n                    });\r\n                }, 800);\r\n            },\r\n        },\r\n        // 伸缩球\r\n        scaleball: {\r\n            type: \"scaleball\",\r\n            r: 15,\r\n            color: \" #a37e22\",\r\n            score: 5,\r\n            prob: 0.96,\r\n            // 短时间内，snakeball半径变小，不容易撞到子弹球\r\n            trigger_head() {\r\n                audio_controller.buff.play(); //播放增益效果音效\r\n                // 缩小snakeball半径\r\n                snakeball.head_radius.act = (snakeball.head_radius.ref * scale_stander) / 2;\r\n                snakeball.body_radius.act = (snakeball.body_radius.ref * scale_stander) / 2;\r\n                // 设置snakeball颜色和半径\r\n                gsap.set(snakeball.balls, {\r\n                    fill: \"#a37e22\",\r\n                    r: (i) => {\r\n                        return i === 0 ? snakeball.head_radius.act : snakeball.body_radius.act;\r\n                    },\r\n                });\r\n                // 储存并清除定时器：防止多次触发、定时器堆叠导致效果时长不够\r\n                if (launcher.types[\"scaleball\"].timer)\r\n                    clearTimeout(launcher.types[\"scaleball\"].timer);\r\n                // 一段时间后，恢复颜色和正常大小\r\n                launcher.types[\"scaleball\"].timer = setTimeout(() => {\r\n                    snakeball.head_radius.act = snakeball.head_radius.ref * scale_stander;\r\n                    snakeball.body_radius.act = snakeball.body_radius.ref * scale_stander;\r\n                    gsap.set(snakeball.balls, {\r\n                        fill: \"\",\r\n                        r: \"\",\r\n                    });\r\n                }, 3000);\r\n            },\r\n            // 界面范围内的所有子弹球变成原来的三倍大\r\n            trigger_body() {\r\n                Object.values(launcher.balls).forEach((ball) => {\r\n                    // 限制子弹球最大为原来半径的9倍，防止该函数多次被触发，子弹球变得过大\r\n                    if (ball.r / launcher.types[ball.type].r / scale_stander >= 9) return;\r\n                    ball.r *= 3;\r\n                    // 更改子弹球半径\r\n                    gsap.set(ball.ball, {\r\n                        r: ball.r,\r\n                    });\r\n                    flicker(ball.ball, \"#a37e22\"); // 闪烁子弹球颜色\r\n                });\r\n            },\r\n        },\r\n        // 分裂球\r\n        splitball: {\r\n            type: \"splitball\",\r\n            r: 12,\r\n            color: \" #ef7706\",\r\n            score: 5,\r\n            prob: 0.96,\r\n            // 分裂一条相同长度的snakeball，与玩家同步运动\r\n            trigger_head() {\r\n                audio_controller.buff.play(); //播放增益效果音效\r\n                let tem_lives = player.lives; //暂存生命，方便后续移除对应生命值\r\n                // 创建新增身体，并设置新增部分颜色\r\n                for (let i = 0; i < tem_lives; i++) {\r\n                    let ball = snakeball.create_ball(\"body\");\r\n                    gsap.set(ball, {\r\n                        fill: \"#ef7706\",\r\n                    });\r\n                }\r\n                // 修改移动方法：使新增身体分裂位移\r\n                snakeball.set_location = (ball, x, y, index) => {\r\n                    // 设置新增身体与原位置偏移\r\n                    let add_x = (parseInt(index / (player.lives + 1)) * innerWidth) / 8;\r\n                    let add_y = (parseInt(index / (player.lives + 1)) * innerHeight) / 8;\r\n                    gsap.to(ball, {\r\n                        pos_x: x + add_x,\r\n                        pos_y: y + add_y,\r\n                        cx: x + add_x,\r\n                        cy: y + add_y,\r\n                        duration: snakeball.duration.act,\r\n                        ease: \"linear\",\r\n                        delay: (index % (player.lives + 1)) * snakeball.delay.act,\r\n                    });\r\n                };\r\n                // 一段时间后恢复\r\n                setTimeout(() => {\r\n                    // 移除新增的身体\r\n                    for (let i = 0; i < tem_lives; i++) {\r\n                        stage.removeChild(snakeball.balls[snakeball.balls.length - 1]);\r\n                        snakeball.balls.pop();\r\n                    }\r\n                    // 恢复移动方法：这里不能临时储存方法然后替换回去，如果多次触发的话，会出BUG\r\n                    snakeball.set_location = (ball, x, y, index) => {\r\n                        gsap.to(ball, {\r\n                            pos_x: x,\r\n                            pos_y: y,\r\n                            cx: x,\r\n                            cy: y,\r\n                            duration: snakeball.duration.act,\r\n                            ease: \"linear\",\r\n                            delay: index * snakeball.delay.act,\r\n                        });\r\n                    };\r\n                }, 3000);\r\n            },\r\n            // 在爆炸处分裂火球\r\n            trigger_body() {\r\n                // 生成随机数个火球\r\n                for (let i = 0; i < Math.random() * 10 + 10; i++) {\r\n                    // 每一次爆炸，必分裂出一个分裂球\r\n                    let type = i === 0 ? \"splitball\" : \"fireball\";\r\n                    // 设置对应属性\r\n                    let r = launcher.types[type].r * scale_stander;\r\n                    let color = launcher.types[type].color;\r\n                    let pos_x = this.pos_x;\r\n                    let pos_y = this.pos_y;\r\n                    let speed_x = (Math.random() - 0.5) * 2 * launcher.max_speed * scale_stander;\r\n                    let speed_y = (Math.random() - 0.5) * 2 * launcher.max_speed * scale_stander;\r\n                    // 生成子弹球对象\r\n                    let ball = new bulletball(r, pos_x, pos_y, speed_x, speed_y, type, color);\r\n                    // 将子弹球用index标记，并储存到balls，方便查找\r\n                    ball.index = launcher.index;\r\n                    launcher.balls[launcher.index] = ball;\r\n                    // 创建子弹球\r\n                    ball.create();\r\n                    launcher.index++;\r\n                }\r\n            },\r\n        },\r\n        // 磁力球\r\n        magneticball: {\r\n            type: \"magneticball\",\r\n            r: 15,\r\n            color: \" #113ede\",\r\n            score: 8,\r\n            prob: 0.985,\r\n            // 界面内范围内的所有子弹球、全部移向snakeball的头部位置\r\n            trigger_head() {\r\n                audio_controller.buff.play(); //播放增益效果音效\r\n                Object.values(launcher.balls).forEach((ball) => {\r\n                    // 计算随机更新子弹球的速度，30毫秒是子弹球移动频率\r\n                    ball.speed_x = (this.pos_x - ball.pos_x) / 30 / (Math.random() * 0.5 + 1);\r\n                    ball.speed_y = (this.pos_y - ball.pos_y) / 30 / (Math.random() * 0.5 + 1);\r\n                    flicker(ball.ball, \"#113ede\"); // 闪烁子弹球颜色\r\n                });\r\n            },\r\n            // snakeball被吸到磁力球爆炸的位置\r\n            trigger_body() {\r\n                // 移除鼠标事件:短时间内无法操控snakeball\r\n                stage.onmousemove = null;\r\n                stage.ontouchmove = null;\r\n                // 移动snakeball到子弹球爆炸位置\r\n                snakeball.move(this.pos_x, this.pos_y);\r\n                // 一段时间后恢复\r\n                snakeball.change_color(\"#113ede\", 1, () => {\r\n                    // 重新绑定事件，可再次操控snakeball\r\n                    snakeball.bind_events();\r\n                });\r\n            },\r\n        },\r\n        // 影子球\r\n        shadowball: {\r\n            type: \"shadowball\",\r\n            r: 10,\r\n            color: \" #9f4df0\",\r\n            score: 8,\r\n            prob: 0.985,\r\n            // 短时间内、让与snakeball碰撞的子弹球、瞬移到snakeball头的周围并减速\r\n            trigger_head() {\r\n                audio_controller.buff.play(); //播放增益效果音效\r\n                // 更改子弹球身体碰撞方法\r\n                bulletball.prototype.crash_body = (ball) => {\r\n                    if (ball.type != \"fireball\") {\r\n                        // 非火球则移动到snakeball头部的位置周围\r\n                        ball.pos_x = snakeball.balls[0].pos_x + Math.random() * 200 - 100;\r\n                        ball.pos_y = snakeball.balls[0].pos_y + Math.random() * 200 - 100;\r\n                        // 减速\r\n                        ball.speed_x /= 5;\r\n                        ball.speed_y /= 5;\r\n                        flicker(ball.ball, \"#9f4df0\"); // 闪烁子弹球颜色\r\n                    } else {\r\n                        // 是火球则正常加分\r\n                        player.score += launcher.types[ball.type].score;\r\n                        ball.destroy();\r\n                    }\r\n                };\r\n                // 标识snakeball颜色\r\n                gsap.set(snakeball.balls, {\r\n                    fill: \"#9f4df0\",\r\n                });\r\n                // 储存并清除定时器：防止多次触发、定时器堆叠导致效果时长不够\r\n                if (launcher.types[\"shadowball\"].timer)\r\n                    clearTimeout(launcher.types[\"shadowball\"].timer);\r\n                // 一段时间后恢复\r\n                launcher.types[\"shadowball\"].timer = setTimeout(() => {\r\n                    // 恢复身体碰撞方法:这里不能临时储存方法然后替换回去，如果多次触发的话，会出BUG\r\n                    bulletball.prototype.crash_body = (ball) => {\r\n                        player.score += launcher.types[ball.type].score;\r\n                        ball.destroy();\r\n                        let trigger_body = launcher.types[ball.type].trigger_body.bind(ball);\r\n                        return trigger_body();\r\n                    };\r\n                    gsap.set(snakeball.balls, {\r\n                        fill: \"\",\r\n                    });\r\n                }, 3000);\r\n            },\r\n            // 短时间后、让所有子弹球随机改变位置\r\n            trigger_body() {\r\n                // 设置颜色预警\r\n                Object.values(launcher.balls).forEach((ball) => {\r\n                    gsap.set(ball.ball, {\r\n                        fill: \"#9f4df0\",\r\n                    });\r\n                });\r\n                // 一段时间后,随机设置所有子弹球位置\r\n                setTimeout(() => {\r\n                    Object.values(launcher.balls).forEach((ball) => {\r\n                        // 恢复颜色\r\n                        gsap.set(ball.ball, {\r\n                            fill: \"\",\r\n                        });\r\n                        // 随机子弹球设置xy位置\r\n                        ball.pos_x = Math.random() * innerWidth;\r\n                        ball.pos_y = Math.random() * innerHeight;\r\n                    });\r\n                }, 500);\r\n            },\r\n        },\r\n        // 隐身球\r\n        invisibleball: {\r\n            type: \"invisibleball\",\r\n            r: 15,\r\n            color: \" #808080\",\r\n            score: 10,\r\n            prob: 0.985,\r\n            // 短时间内让snakeball隐身，无法碰撞到子弹球\r\n            trigger_head() {\r\n                audio_controller.buff.play(); //播放增益效果音效\r\n                // 临时储存check_crash方法，方便后续替换回去，这里可以用临时储存的方法，因为不存在多次触发的情况\r\n                let tem_check_crash = bulletball.prototype.check_crash;\r\n                // 移除子弹球的撞击检测方法：让子弹球无法撞击snakeball\r\n                bulletball.prototype.check_crash = () => {};\r\n                // 设置snakeball半透明\r\n                gsap.set(snakeball.balls, {\r\n                    opacity: 0.5,\r\n                });\r\n                // 一段时间后恢复\r\n                setTimeout(() => {\r\n                    // 恢复子弹球撞击检测\r\n                    bulletball.prototype.check_crash = tem_check_crash;\r\n                    // 如果游戏还在进行中：则恢复snakeball透明度\r\n                    if (game_controler.if_gaming)\r\n                        gsap.set(snakeball.balls, {\r\n                            opacity: 1,\r\n                        });\r\n                }, 3000);\r\n            },\r\n            // 短时间内让所有子弹球隐身\r\n            trigger_body() {\r\n                // 设置所有子弹球透明度为0\r\n                Object.values(launcher.balls).forEach((ball) => {\r\n                    gsap.to(ball.ball, {\r\n                        opacity: 0,\r\n                        duration: 0.5,\r\n                        ease: \"power3.out\",\r\n                    });\r\n                });\r\n                // 储存并清除定时器：防止多次触发，造成子弹球闪烁以及隐身时长不够\r\n                if (launcher.types[\"invisibleball\"].timer)\r\n                    clearTimeout(launcher.types[\"invisibleball\"].timer);\r\n                // 一段时间后，撤销隐身效果\r\n                launcher.types[\"invisibleball\"].timer = setTimeout(() => {\r\n                    // 如果游戏还在进行中：恢复所有子弹球透明度\r\n                    if (game_controler.if_gaming)\r\n                        Object.values(launcher.balls).forEach((ball) => {\r\n                            gsap.to(ball.ball, {\r\n                                opacity: 1,\r\n                                duration: 0.5,\r\n                                ease: \"power3.out\",\r\n                            });\r\n                        });\r\n                }, 3000);\r\n            },\r\n        },\r\n        // 信号球\r\n        signalball: {\r\n            type: \"signalball\",\r\n            r: 8,\r\n            color: \" #ea4fc0\",\r\n            score: 20,\r\n            prob: 0.99,\r\n            // 短时间内生成大量身体，但不增加生命，一段时间后恢复\r\n            trigger_head() {\r\n                audio_controller.buff.play(); //播放增益效果音效\r\n                // 使snakeball有一个顺滑的操控\r\n                snakeball.duration.act = snakeball.duration.default;\r\n                snakeball.delay.act = 0.02;\r\n                // 创建身体\r\n                for (let i = 0; i < 50; i++) {\r\n                    snakeball.create_ball(\"body\");\r\n                }\r\n                // 标识snakeball颜色，一段时间后恢复\r\n                snakeball.change_color(\"#ea4fc0\", 3, () => {\r\n                    // 移除新增的身体，恢复颜色\r\n                    for (let i = 0; i < 50; i++) {\r\n                        stage.removeChild(snakeball.balls[snakeball.balls.length - 1]);\r\n                        snakeball.balls.pop();\r\n                    }\r\n                });\r\n            },\r\n            // 短时间内，涌出大量子弹球\r\n            trigger_body() {\r\n                // 重置launcher的定时器，设置发射频率极高\r\n                clearInterval(launcher.timer);\r\n                launcher.timer = setInterval(launcher.launch.bind(launcher), 1);\r\n                // 设置在大量发射子弹球的时间段里面、不再发射信号球，避免造成超多子弹球，极易让玩家死亡\r\n                launcher.types[\"signalball\"].prob = 2;\r\n                // 储存并清除定时器：防止多次触发、定时器堆叠导致效果时长不够\r\n                if (launcher.types[\"signalball\"].timer)\r\n                    clearTimeout(launcher.types[\"signalball\"].timer);\r\n                // 短时间后，恢复原始发射频率\r\n                launcher.types[\"signalball\"].timer = setTimeout(() => {\r\n                    // 恢复信号球发射概率\r\n                    launcher.types[\"signalball\"].prob = 0.99;\r\n                    clearInterval(launcher.timer);\r\n                    // 如果游戏还在进行中：用原频率重新启动炮台，这里一定要确定游戏还在进行，否则会出BUG\r\n                    if (game_controler.if_gaming)\r\n                        launcher.timer = setInterval(\r\n                            launcher.launch.bind(launcher),\r\n                            launcher.frequency\r\n                        );\r\n                }, 800);\r\n            },\r\n        },\r\n        // 核弹球\r\n        hball: {\r\n            type: \"hball\",\r\n            r: 30,\r\n            color: \" #046312\",\r\n            score: 50,\r\n            prob: 0.995,\r\n            // 界面范围内所有子弹球爆炸，并获取对应得分\r\n            trigger_head() {\r\n                audio_controller.buff.play(); //播放增益效果音效\r\n                Object.values(launcher.balls).forEach((ball) => {\r\n                    player.score += launcher.types[ball.type].score;\r\n                    if (!ball.if_removed) ball.destroy();\r\n                });\r\n            },\r\n            // 直接丢失5条生命值\r\n            trigger_body() {\r\n                audio_controller.warn.play(); //播放警示音效\r\n                for (let i = 0; i <= 5; i++) {\r\n                    // 如果玩家已经死亡：则不执行，否则会报错\r\n                    if (player.lives > 0) snakeball.lost_lives();\r\n                }\r\n            },\r\n        },\r\n    },\r\n    balls: {}, //所有的子弹球：这里用对象储存以方便查找指定子弹球\r\n    index: 0, //计数：用于查找子弹球\r\n    frequency: 250, //发射频率\r\n    max_speed: 10, //子弹球本局游戏最高可达的移动速度\r\n    timer: null, //发射定时器\r\n    // 运行launcher\r\n    run() {\r\n        // 更新所有子弹球和index\r\n        this.balls = {};\r\n        this.index = 0;\r\n        // 开启定时器，发射子弹球\r\n        this.timer = setInterval(this.launch.bind(this), this.frequency);\r\n    },\r\n    // 发射子弹球\r\n    launch() {\r\n        let r, pos_x, pos_y, speed_x, speed_y, type, color;\r\n        // 设置随机种类的子弹球\r\n        Object.values(this.types).forEach((ball) => {\r\n            if (Math.random() > ball.prob) return (type = ball.type);\r\n        });\r\n        r = this.types[type].r * scale_stander;\r\n        color = this.types[type].color;\r\n        // 设置子弹球从界面外部的进入方向\r\n        let direction = Math.floor(Math.random() * 4);\r\n        switch (direction) {\r\n            case 0: // 从左侧进入\r\n                pos_x = -r; // 球的初始位置在视图左侧外\r\n                speed_x = Math.random() * this.max_speed * scale_stander + 1; // 速度向右\r\n                pos_y = Math.random() * innerHeight; // 随机垂直位置\r\n                speed_y = (Math.random() - 0.5) * 2 * this.max_speed * scale_stander; // 随机垂直速度，可以是向上或向下\r\n                break;\r\n            case 1: // 从右侧进入\r\n                pos_x = innerWidth + r; // 球的初始位置在视图右侧外\r\n                speed_x = Math.random() * -this.max_speed * scale_stander - 1; // 速度向左\r\n                pos_y = Math.random() * innerHeight; // 随机垂直位置\r\n                speed_y = (Math.random() - 0.5) * 2 * this.max_speed * scale_stander; // 随机垂直速度，可以是向上或向下\r\n                break;\r\n            case 2: // 从上方进入\r\n                pos_y = -r; // 球的初始位置在视图上方外\r\n                speed_y = Math.random() * this.max_speed * scale_stander + 1; // 速度向下\r\n                pos_x = Math.random() * innerWidth; // 随机水平位置\r\n                speed_x = (Math.random() - 0.5) * 2 * this.max_speed * scale_stander; // 随机水平速度，可以是向左或向右\r\n                break;\r\n            case 3: // 从下方进入\r\n                pos_y = innerHeight + r; // 球的初始位置在视图下方外\r\n                speed_y = Math.random() * -this.max_speed * scale_stander - 1; // 速度向上\r\n                pos_x = Math.random() * innerWidth; // 随机水平位置\r\n                speed_x = (Math.random() - 0.5) * 2 * this.max_speed * scale_stander; // 随机水平速度，可以是向左或向右\r\n                break;\r\n        }\r\n        // 生成子弹球对象\r\n        let ball = new bulletball(r, pos_x, pos_y, speed_x, speed_y, type, color);\r\n        // 将子弹球用index标记，并储存到balls，方便查找\r\n        ball.index = this.index;\r\n        this.balls[this.index] = ball;\r\n        // 创建子弹球\r\n        ball.create();\r\n        this.index++;\r\n    },\r\n    // 摧毁所有子弹球\r\n    destroy() {\r\n        clearInterval(this.timer); //清除发射定时器\r\n        // 这里只给所有子弹球播放爆炸动画、而不清除，是因为后面再次游戏时，会直接清除整个stage\r\n        Object.values(this.balls).forEach((ball) => {\r\n            clearInterval(ball.move_timer);\r\n            gsap.to(ball.ball, {\r\n                fill: \"#e3d80f\",\r\n                stroke: \"#dc1130\",\r\n                strokeWidth: ball.r / 5, //这里用半径计算线条宽度、是为了不让其受屏幕尺寸影响\r\n                r: 2 * ball.r,\r\n                opacity: 0,\r\n                duration: 0.3,\r\n                ease: \"power3.out\",\r\n            });\r\n        });\r\n    },\r\n};\r\n// 游戏控制器\r\nconst game_controler = {\r\n    // wave关卡控制器\r\n    waver: {\r\n        timer: null, //定时器\r\n        default_time: 40, //每一关的默认时长\r\n    },\r\n    initial_lives: 20, //玩家的初始生命值\r\n    if_gaming: false, //是否在进行游戏中\r\n    // 创建关卡：一般关卡会在游戏正式开始之前创建\r\n    create_wave() {\r\n        stage.innerHTML = \"\"; //清空游戏舞台\r\n        // 如果玩家未激活：已死亡/首次创建\r\n        if (!player.if_active) {\r\n            // 设置默认玩家信息\r\n            player.if_active = true; //激活玩家\r\n            player.wave = player.rank = player.score = 0;\r\n            player.lives = this.initial_lives;\r\n        }\r\n        this.upgrade(); //升级游戏：设置关卡难度参数\r\n        player.time = this.waver.default_time; //重置游戏时间\r\n        snakeball.create(player.lives); //创建snakeball\r\n    },\r\n    // 正式开始游戏\r\n    start() {\r\n        this.if_gaming = true;\r\n        audio_controller.gameing.play(); //播放游戏音乐\r\n        snakeball.reseter.run(); //启动reseter：开始周期重置snakeball\r\n        launcher.run(); //开始发射子弹球\r\n        // 开启waver：进行倒计时，倒计时完成、则结束关卡\r\n        this.waver.timer = setInterval(() => {\r\n            player.time--;\r\n            // 倒计时结束，并且玩家未死亡：游戏关卡胜利\r\n            if (player.time <= 0 && player.if_active) this.over(true);\r\n        }, 1000);\r\n    },\r\n    // 游戏结束\r\n    over(if_win) {\r\n        this.if_gaming = false;\r\n        // this.post(); //提交玩家数据\r\n        this.clean(); //清扫游戏舞台\r\n        // 停止游戏音乐、并播放大厅音乐\r\n        audio_controller.gameing.stop();\r\n        audio_controller.hall.play();\r\n        audio_controller.hall.fade(0, 1, 9000);\r\n        //显示总结面板\r\n        summary.value.show();\r\n        // 游戏关卡胜利\r\n        if (if_win) audio_controller.win.play();\r\n        // 游戏关卡失败\r\n        else {\r\n            audio_controller.fail.play();\r\n            // 设置玩家未激活：即死亡，并归零游戏时间\r\n            player.if_active = false;\r\n            player.time = 0;\r\n        }\r\n    },\r\n    // 清扫游戏舞台\r\n    clean() {\r\n        clearInterval(this.waver.timer);\r\n        launcher.destroy();\r\n        snakeball.remove();\r\n        snakeball.reseter.stop();\r\n    },\r\n    // 升级\r\n    upgrade() {\r\n        player.wave++;\r\n        // 升级频率: 频率范围为250-40，增长速度为曲线，先快后慢、最后平稳\r\n        launcher.frequency = 40 + (250 - 40) * Math.exp(-0.08 * player.wave);\r\n        // 升级速度: 速度范围为10-25，增长速度同上\r\n        launcher.max_speed = 10 + (25 - 10) * (1 - Math.exp(-0.08 * player.wave));\r\n        // 加快游戏音乐，音乐速度范围为1-2\r\n        audio_controller.gameing.rate(1 + (2 - 1) * (1 - Math.exp(-0.08 * player.wave)));\r\n    },\r\n    // 提交玩家数据\r\n    post() {\r\n        let data = {\r\n            id: player.id,\r\n            name: player.name,\r\n            wave: player.wave,\r\n            lives: player.lives,\r\n            score: player.score,\r\n        };\r\n        // RAS加密\r\n        const public_key = forge.pki.publicKeyFromPem(`-----BEGIN PUBLIC KEY-----\r\nxxxxxxx\r\n-----END PUBLIC KEY-----`);\r\n        // 生成加密数据\r\n        const encrypted_data = public_key.encrypt(JSON.stringify(data), \"RSA-OAEP\", {\r\n            md: forge.md.sha256.create(),\r\n        });\r\n        // 将加密数据转换为Base64\r\n        const encrypted_base64 = forge.util.encode64(encrypted_data);\r\n        // 发送数据\r\n        let xhr = new XMLHttpRequest();\r\n        xhr.open(\"POST\", \"https://put_your_server.com/api\", true);\r\n        xhr.setRequestHeader(\"Content-type\", \"application/json\");\r\n        xhr.send(JSON.stringify({ encrypted_data: encrypted_base64 }));\r\n    },\r\n};\r\n// 储存全局功能函数\r\nstore.ready_to_game = () => {\r\n    // 在准备提示出现前，就创建关卡、可以看到snakeball。准备提示结束之后，才正式开始游戏\r\n    readytips.value.ready(\r\n        game_controler.create_wave.bind(game_controler),\r\n        game_controler.start.bind(game_controler)\r\n    );\r\n};\r\nonMounted(() => {\r\n    stage = document.querySelector(\"#stage\");\r\n    window.addEventListener(\"resize\", resize);\r\n    resize();\r\n});\r\n</script>\r\n"],"mappings":";;uBAAAA,mBAAA,CAAAC,SAAA,S,0BACIC,mBAAA,CAAsC;IAAjCC,EAAE,EAAC,OAAO;IAACC,KAAK,EAAC;+BACtBC,YAAA,CAA2BC,MAAA;IAAjBC,GAAG,EAAC;EAAU,gCACxBF,YAAA,CAA6BC,MAAA;IAAlBC,GAAG,EAAC;EAAW,gCAC1BF,YAAA,CAAyBC,MAAA;IAAhBC,GAAG,EAAC;EAAS,gCACtBF,YAAA,CAAWC,MAAA,a","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}